<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019 ICPC南京站总结</title>
      <link href="/2019/10/27/icpc2019-nanjing/"/>
      <url>/2019/10/27/icpc2019-nanjing/</url>
      
        <content type="html"><![CDATA[<p>这次到南京站也还算有收获，终于没有打铁了（多亏队友</p><a id="more"></a><p>首先拿到题面第一题看的C，判断是dfs枚举每个方格的次态，但是当时没有好好读题，直到后面队友指出才发现可以从1开始。。。<br>不过还好，做法区别也不大，多开了4维保存一下有多少个长度为k的后继就可以了。结果一发过了。算是弥补我们队没及时签上A题的遗憾。</p><p>然后A题结果就是结论题，这题基本没参与，但是事后看过来真的很容易想多，要不是看到其他人过的很快马上推翻筛素数的想法，可能一直要WA或者TLE。（想太多了）</p><p>接下来看的是K题，计算几何，当时看到给了8秒找点，以为又是跟去年一样的模拟退火。<br>结果一看T太大了，搞不了。<br>最后发现只要确定了平分点所处的边，在这条边上移动，两边的面积就是单调变化的。<br>直接二分写的，模板过于复杂没有用，结对编程找了不少错，终于跌跌撞撞过了，但是因为测试不够还是WA了几发，以及一次把精度开太高了的不必要罚时。（论测试的重要性）</p><p>然后就是H题，其实也是结论题，但是由于题面太绕，WA的第一反应不是检查边界条件而是总想着是不是读错题了，是不是结论不对。<br>但是其实就是一个很简单的边界值，很多人没想到，想到就很简单。</p><p>最后看了剩下过的人最多的J，数据范围很大，只能想到离散化，进一步就想不到了。<br>还有一个大模拟的G其实也应该看看，但是一个人没交，想着还是算了。。。（还是菜</p><p>总体而言，能够拿到铜牌也算是有所收获，但是由于这样或那样原因，还是产生了一些不应该的失误。<br>以后吸取这次的教训～</p><p>PS：这次也算是收获了平面几何的做法（用复数），可以减少不少代码量。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> ICPC </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包的路由转圈圈——谈谈使用nftables配置透明代理碰到的那些坑</title>
      <link href="/2019/08/19/tproxy-config-with-nftables/"/>
      <url>/2019/08/19/tproxy-config-with-nftables/</url>
      
        <content type="html"><![CDATA[<img src="/2019/08/19/tproxy-config-with-nftables/package_lost.png" title="灵魂画手上线"><p>透明代理，可以使得在代理后面的所有流量都经过代理，而发出流量的软件本身并不知道代理的存在。但网上大多配置教程都以iptables为主，由于本人用的是nftables，就尝试依葫芦画瓢搞了一个，同时也大概弄清除了其中的原理，供参考。</p><a id="more"></a><p>首先要准备一个透明代理客户端，如ss_redir，在PROXY_PORT进行监听。然后针对TCP和UDP设置不同的规则。</p><hr><h2 id="TCP部分"><a href="#TCP部分" class="headerlink" title="TCP部分"></a>TCP部分</h2><p>TCP是比较容易进行转发的，只需要在nftables里面进行设置forward就行了。<br>为了让配置文件看起来更直观，首先将需要绕过不走代理的ip（本地地址、远程代理服务器的地址等）放到一个文件里，这里以/etc/whitelist.ips为例子，文件结构如下所示。</p><p>PS:这里非常重要，必须配置对，否则会形成环路循环转发</p><p><code>/etc/whitelist.ips</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define whitelist = &#123;</span><br><span class="line">    127.0.0.1/24,</span><br><span class="line">    192.168.0.0/16,</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里不要出现有交集的ip区间，否则会报错。</p><p>然后开始编辑nftables的配置文件（使用<code>nft</code>命令时，当priority为负值时会出错，遇到这种情况时需要直接编辑/etc/nftables.conf以后使用<code>nft flush ruleset &amp;&amp; nft -f /etc/nftables.conf</code>导入配置文件。</p><p>首先在配置文件开头插入这一句，导入白名单文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;/etc/whitelist.ips&quot;</span><br></pre></td></tr></table></figure><p>然后对应iptables的nat表，配置文件添加如下的一个nat表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">table ip nat &#123;</span><br><span class="line">    set whitelistset &#123;</span><br><span class="line">        type ipv4_addr</span><br><span class="line">        flag interval</span><br><span class="line">        elements = $whitelist</span><br><span class="line">    &#125;</span><br><span class="line">    chain proxy &#123;</span><br><span class="line">        ip daddr @whitelist return</span><br><span class="line">        ip protocol tcp redirect to :[PROXY_PORT]</span><br><span class="line">    &#125;</span><br><span class="line">    chain output &#123;</span><br><span class="line">        type nat hook output priority filter; policy accept;</span><br><span class="line">        jump proxy</span><br><span class="line">    &#125;</span><br><span class="line">    chain prerouting &#123;</span><br><span class="line">        type nat hook output prerouting priority dstnat; policy accept;</span><br><span class="line">        jump proxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的PROXY_PORT换成你实际的透明代理的端口，可以看到这样会将这台机器上产生的流量（由output链控制）和经过这台机器路由的流量（比如这台机器是路由器，由prerouting链控制）转发到本地的PROXY_PORT端口。<br>在linux中，代理程序可以通过调用一些内核提供的API来获取TCP包转发前的目的地址和端口，这样的话直接转发给透明代理就可以很好的处理。但是UDP不能这样做，内核并不允许获取原来的这些信息。所以对于UDP，我们就需要用到另外一种方法。</p><hr><h2 id="UDP部分"><a href="#UDP部分" class="headerlink" title="UDP部分"></a>UDP部分</h2><p>UDP的透明代理，需要借助一个内核模块，叫做TPROXY，他可以在不改变数据包的目的地址的情况下进行路由转发，nftables中可以调用这个模块，在很多iptables配置的文章中也已经介绍过，这里不再展开做介绍。<br>同样的，编辑/etc/nftables.conf，对应iptables中的mangle表，添加如下配置的一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">table ip mangle&#123;</span><br><span class="line">    set whitelistset &#123;</span><br><span class="line">        type ipv4_addr</span><br><span class="line">        flags interval</span><br><span class="line">        elements = $whitelist</span><br><span class="line">    &#125;</span><br><span class="line">    chain output &#123;</span><br><span class="line">        type route hook output priority mangle;policy accept;</span><br><span class="line">        ip daddr @whitelistset return</span><br><span class="line">        ip protocol udp mark set 0x233</span><br><span class="line">    &#125;</span><br><span class="line">    chain prerouting &#123;</span><br><span class="line">        type filter hook prerouting priority mangle; policy accept;</span><br><span class="line">        ip daddr @whitelistset return</span><br><span class="line">        ip protocol udp tproxy to 127.0.0.1:PROXY_PORT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们做的，在mangle表中创建了两条链，output链的type为route，这里的route就是对应了iptables的mangle表，但是route type只能hook output点，所以prerouting链的type就变成了filter。<br>由于TPROXY只能在prerouting链处理，在nftables的流向图中（文后附），output链之后，还跟了一个reroute的流程，要触发这个reroute，我们就需要给数据包头部打上标签（任意一个数值，这里是0x233）。这样在reroute阶段，系统会检测到数据包的头部发生了改变，于是数据包被打到prerouting的地方重新进行路由。<br>而在prerouting阶段，被reroute的数据包和经过本机路由的数据包一起，如过目的地址不在白名单中，就tproxy打到透明代理去。整个过程非常清晰明了。</p><p>PS：在网上的许多教程中，都提到需要进行这样的两条操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip rule add fwmark 0x233 lookup 100</span><br><span class="line">ip route add local 0.0.0.0/0 dev lo table 100</span><br></pre></td></tr></table></figure><p>其作用是将标记为0x233，并且目标为本地地址的数据包经过回环网口送出，但是经过本人实际测试，加和不加并没有什么区别，我认为即使不配置，默认情况系统也应该已经能够知道这条规则，所以并不需要添加。如果有不对的地方，希望读者不吝赐教。</p><img src="/2019/08/19/tproxy-config-with-nftables/nf-packet-flow.svg" title="附nftables流向图">]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
            <tag> nftables </tag>
            
            <tag> 防火墙 </tag>
            
            <tag> 路由 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客重建</title>
      <link href="/2019/08/19/blog_revive/"/>
      <url>/2019/08/19/blog_revive/</url>
      
        <content type="html"><![CDATA[<p>今天，失踪以久的博客终于恢复了，之前一直托管在<a href="https://www.hostker.com" target="_blank" rel="noopener">Hostker</a>上面，后面忘记付费，在<em>没有备份</em>的情况下站点全被删了。。。<br>痛定思痛，还好部分文章还有写作时的md文档，有时间再搬上来。。现在一鼓作气直接使用hexo迁移到github上了，避免了被删库的烦恼。</p><p>以上</p>]]></content>
      
      
      <categories>
          
          <category> 公告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
